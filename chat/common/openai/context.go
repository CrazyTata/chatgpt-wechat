package openai

import (
	"context"
	"encoding/json"
	"fmt"

	"chat/common/redis"

	"github.com/google/uuid"
)

// UserContext is the context of a user once started a chat session
type UserContext struct {
	SessionKey   string             `json:"session_key"`    // 会话ID
	Model        string             `json:"model"`          // 模型
	Prompt       string             `json:"prompt"`         // 对话基础设定
	UserUniqueID string             `json:"user_unique_id"` // 用户唯一标识
	Messages     []ChatModelMessage `json:"messages"`       // 存储此会话的完整上下文
	Summary      []ChatModelMessage `json:"summary"`        // 存储此会话的实际上下文
	MaxTokens    int                `json:"max_tokens"`     // 需要控制的最大token数
	Client       *ChatClient        `json:"chat_client"`    // openai 客户端
}

func GetUserUniqueID(userId string, agentID string) string {
	return fmt.Sprintf(redis.UserSessionAgentDefaultKey, userId, agentID)
}

func UserSessionListKey(UserUniqueID string) string {
	return fmt.Sprintf(redis.UserSessionListKey, UserUniqueID)
}

func getSessionKey(sessionKey string) string {
	return fmt.Sprintf(redis.SessionKey, sessionKey)
}

// NewUserContext 通过用户唯一标识获取会话上下文
func NewUserContext(userUniqueID string) *UserContext {
	// 去 redis 中 获取 userUniqueID 对应的会话ID
	sessionKey, _ := redis.Rdb.Get(context.Background(), userUniqueID).Result()
	fmt.Println("sessionKey", sessionKey)
	if sessionKey == "" {
		// 创建新的会话
		sessionKey = uuid.New().String()

		// 存入 redis
		redis.Rdb.Set(context.Background(), userUniqueID, sessionKey, 0)
		redis.Rdb.SAdd(context.Background(), UserSessionListKey(userUniqueID), sessionKey)
	}

	// 再通过 会话ID 从 redis 中 获取 会话上下文
	data, _ := redis.Rdb.Get(context.Background(), getSessionKey(sessionKey)).Result()
	fmt.Println("data", data)
	if data == "" {
		res := UserContext{
			SessionKey:   sessionKey,
			UserUniqueID: userUniqueID,
			MaxTokens:    4096,
		}
		byteData, _ := json.Marshal(res)
		redis.Rdb.Set(context.Background(), getSessionKey(sessionKey), string(byteData), 0)
		return &res
	}

	// 反序列化
	res := new(UserContext)
	_ = json.Unmarshal([]byte(data), res)
	return res
}

func (c *UserContext) WithModel(model string) *UserContext {
	c.Model = model
	return c
}

func (c *UserContext) WithPrompt(prompt string) *UserContext {
	c.Prompt = prompt
	return c
}

func (c *UserContext) GetSummary() []ChatModelMessage {
	return c.Summary
}

// WithClient 通过 openai 客户端初始化会话上下文
func (c *UserContext) WithClient(client *ChatClient) *UserContext {
	c.Client = client
	return c
}

func (c *UserContext) Set(q, a string, save bool) *UserContext {

	if q != "" {
		c.Messages = append(c.Messages, ChatModelMessage{
			Role:    "user",
			Content: q,
		})
	}

	if a != "" {
		c.Messages = append(c.Messages, ChatModelMessage{
			Role:    "assistant",
			Content: a,
		})
	}

	if q != "" {
		c.Summary = append(c.Summary, ChatModelMessage{
			Role:    "user",
			Content: q,
		})
	}

	if a != "" {
		c.Summary = append(c.Summary, ChatModelMessage{
			Role:    "assistant",
			Content: a,
		})
	}

	if save {
		// 去保存数据
		byteData, _ := json.Marshal(c)
		redis.Rdb.Set(context.Background(), getSessionKey(c.SessionKey), string(byteData), 0)
		// 一个汉字大概 2.7 ~ 1.9 个token，最大长度为 4000 / ( 2.7 ~ 1.9) = 1480 ~ 2100 左右
		countMessage := ""
		for _, message := range c.Summary {
			countMessage += message.Content
		}
		if len([]rune(countMessage)) > 700 {
			// 调用 openai api 进行 summary 简化到 300 字以内
			go func() {
				summary := c.getCompletionSummary()
				// 生成新的 summary
				newSummary, err := c.doSummary(summary)
				if err != nil {
					fmt.Println("summary error", err)
					return
				}
				// 将新的 summary 赋值给 c.Summary
				c.Summary = newSummary
				// 重新保存数据
				byteData, _ := json.Marshal(c)
				redis.Rdb.Set(context.Background(), getSessionKey(c.SessionKey), string(byteData), 0)
			}()
		}
	}
	return c
}

func (c *UserContext) doSummary(summary string) ([]ChatModelMessage, error) {
	prompt := "请总结以下信息至100字内,并以json形式进行响应，如：{\"summary\":[{\"q\":\"问题\",\"a\":\"回答\"}]}\n" + summary

	// 调用 openai api 进行 summary 简化到 100 字以内
	summaryStr, err := c.Client.WithModel(TextModel).Completion(prompt)

	type AutoGenerated struct {
		Summary []struct {
			Q string `json:"q"`
			A string `json:"a"`
		} `json:"summary"`
	}

	if err == nil {
		start := 0
		var lens string
		var summary AutoGenerated
		err = json.Unmarshal([]byte(summaryStr), &summary)
		if err != nil {
			return c.Summary, err
		}

		var newSummary []ChatModelMessage
		for i := 0; i < len(summary.Summary); i++ {
			s := summary.Summary[len(summary.Summary)-i-1]
			lens = s.Q + s.A
			if len([]rune(lens)) > 200 {
				start = len(summary.Summary) - i
			}
		}
		for _, val := range summary.Summary[start:] {
			newSummary = append(newSummary, ChatModelMessage{
				Role:    "user",
				Content: val.Q,
			})
			newSummary = append(newSummary, ChatModelMessage{
				Role:    "assistant",
				Content: val.A,
			})
		}
		return newSummary, nil
	}
	return c.Summary, err
}

// GetCompletionSummary 获取补全的摘要
func (c *UserContext) GetCompletionSummary() string {
	basePrompt := c.Prompt + "\n"
	l := len(c.Summary)
	for k, val := range c.Summary {
		switch val.Role {
		case "user":
			basePrompt += "Q: " + val.Content + "\n"
			if l == k+1 {
				basePrompt += "A: "
			}
		case "assistant":
			basePrompt += "A: " + val.Content + "\n"
		}
	}
	return basePrompt
}

// GetChatSummary 获取对话摘要
func (c *UserContext) GetChatSummary() []ChatModelMessage {
	var summary []ChatModelMessage
	summary = append(summary, ChatModelMessage{
		Role:    "system",
		Content: c.Prompt,
	})
	summary = append(summary, c.Summary...)
	return summary
}

func (c *UserContext) getCompletionSummary() string {
	basePrompt := ""
	l := len(c.Summary)
	for k, val := range c.Summary {
		switch val.Role {
		case "user":
			basePrompt += "Q: " + val.Content + "\n"
			if l == k+1 {
				basePrompt += "A: "
			}
		case "assistant":
			basePrompt += "A: " + val.Content + "\n"
		}
	}
	return basePrompt
}

func NewSession(userUniqueID string) {
	// 去 redis 中 获取 userUniqueID 对应的会话ID
	sessionKey := uuid.New().String()
	// 存入 redis
	redis.Rdb.Set(context.Background(), userUniqueID, sessionKey, 0)
	redis.Rdb.SAdd(context.Background(), UserSessionListKey(userUniqueID), sessionKey)
}

// SetSession 设置用户的会话
func SetSession(userUniqueID string, sessionKey string) error {
	//判断集合中是否存在此会话
	if redis.Rdb.SIsMember(context.Background(), UserSessionListKey(userUniqueID), sessionKey).Val() {
		redis.Rdb.Set(context.Background(), userUniqueID, sessionKey, 0)
		return nil
	}
	return fmt.Errorf("此 seession 不存在或已被删除～")
}

// GetSessions 获取用户的所有会话
func GetSessions(userUniqueID string) []string {
	// 去 redis 中 获取 userUniqueID 对应的会话ID
	sessionKeys, _ := redis.Rdb.SMembers(context.Background(), UserSessionListKey(userUniqueID)).Result()

	return sessionKeys
}

// ClearSessions 清除用户的所有会话
func ClearSessions(userUniqueID string) {
	// 去 redis 中 获取 userUniqueID 对应的会话ID
	sessionKeys, _ := redis.Rdb.SMembers(context.Background(), UserSessionListKey(userUniqueID)).Result()
	for _, sessionKey := range sessionKeys {
		redis.Rdb.Del(context.Background(), getSessionKey(sessionKey))
	}
	redis.Rdb.Del(context.Background(), UserSessionListKey(userUniqueID))
}

// Clear 清除会话上下文
func (c *UserContext) Clear() {
	_, _ = redis.Rdb.Del(context.Background(), c.UserUniqueID).Result()
	_, _ = redis.Rdb.Del(context.Background(), getSessionKey(c.SessionKey)).Result()
	_, _ = redis.Rdb.SRem(context.Background(), UserSessionListKey(c.UserUniqueID), c.SessionKey).Result()
}
